'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _lodash = require('lodash.omit');

var _lodash2 = _interopRequireDefault(_lodash);

var _enigmaTable = require('enigma-table');

var _enigmaTable2 = _interopRequireDefault(_enigmaTable);

var _UIView2 = require('../UIView');

var _UIView3 = _interopRequireDefault(_UIView2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * React wrapper for Table.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class UITable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

function didColumnsChange(current_columns, prev_columns, table_internal_columns) {
    /*
        1. there should be the same number of columns
        2. the columns should exactly match in the proper order
        3. each column property should be exactly the same
     */

    if (current_columns.length !== prev_columns.length) {
        return true;
    }

    // did the column descriptors change in some way, or did the width change?
    // this will also catch if the order of the columns changed when comparing
    // the mapping property
    return current_columns.some(function (column, index) {
        return column.mapping !== prev_columns[index].mapping || column.title !== prev_columns[index].title || column.resizable !== prev_columns[index].resizable || column.width !== undefined && column.width !== table_internal_columns[index].width;
    });
}

var UITable = function (_UIView) {
    _inherits(UITable, _UIView);

    function UITable() {
        _classCallCheck(this, UITable);

        return _possibleConstructorReturn(this, _UIView.apply(this, arguments));
    }

    UITable.prototype.getSubviewConfiguration = function getSubviewConfiguration() {
        return {
            wrapper: this.refs.wrapper,
            header: this.refs.header,
            body: this.refs.body,
            'x-scroll-track': this.refs['x-scroll-track'],
            'x-scroll-handle': this.refs['x-scroll-handle'],
            'y-scroll-track': this.refs['y-scroll-track'],
            'y-scroll-handle': this.refs['y-scroll-handle'],
            aria: this.refs.aria,

            columns: this.props.columns,
            rowClickFunc: this.props.onRowInteract,
            cellClickFunc: this.props.onCellInteract,
            onColumnResize: this.props.onColumnResize,
            getRow: this.props.getRow,
            preserveScrollState: this.props.preserveScrollState,
            throttleInterval: this.props.throttleInterval,
            totalRows: this.props.totalRows
        };
    };

    UITable.prototype.componentDidMount = function componentDidMount() {
        this.table = new _enigmaTable2.default(this.getSubviewConfiguration());

        if (this.props.jumpToRowIndex) {
            this.table.jumpToRowIndex(this.props.jumpToRowIndex);
        }
    };

    UITable.prototype.componentWillUnmount = function componentWillUnmount() {
        this.table.destroy();
        this.table = null;
    };

    UITable.prototype.componentDidUpdate = function componentDidUpdate(prev_props) {
        var props = this.props;

        var changed_props = [];
        var key = void 0;

        /* bidirectional key change detection */

        for (key in props) {
            if (props[key] !== prev_props[key]) {
                changed_props.push(key);
            }
        }

        for (key in prev_props) {
            if (prev_props[key] !== props[key] && changed_props.indexOf(key) === -1) {
                changed_props.push(key);
            }
        }

        if (changed_props.length) {
            if (changed_props.indexOf('jumpToRowIndex') !== -1) {
                /* jumpToRowIndex already triggers a regeneration, just avoiding running it twice */
                return this.table.jumpToRowIndex(props.jumpToRowIndex);
            }

            if (changed_props.length === 1 && changed_props[0] === 'columns') {
                /* did things materially change, or just updating a column width? */
                if (didColumnsChange(props.columns, prev_props.columns, this.table.columns) === false) {
                    return;
                }
            }

            this.table.regenerate(this.getSubviewConfiguration());
        }
    };

    UITable.prototype.renderXScroll = function renderXScroll() {
        return _react2.default.createElement(
            'div',
            { ref: 'x-scroll-track', className: 'ui-table-x-scroll-track' },
            _react2.default.createElement('div', { ref: 'x-scroll-handle', className: 'ui-table-x-scroll-handle' })
        );
    };

    UITable.prototype.renderYScroll = function renderYScroll() {
        return _react2.default.createElement(
            'div',
            { ref: 'y-scroll-track', className: 'ui-table-y-scroll-track' },
            _react2.default.createElement('div', { ref: 'y-scroll-handle', className: 'ui-table-y-scroll-handle' })
        );
    };

    UITable.prototype.renderAria = function renderAria() {
        return _react2.default.createElement('div', { ref: 'aria', className: this.props.offscreenClass || 'ui-offscreen', 'aria-live': 'polite' });
    };

    UITable.prototype.render = function render() {
        return _react2.default.createElement(
            'div',
            _extends({}, (0, _lodash2.default)(this.props, UITable.internal_keys), {
                ref: 'wrapper',
                className: 'ui-table-wrapper ' + this.props.className,
                'data-set-identifier': this.props.identifier,
                tabIndex: '0' }),
            _react2.default.createElement('div', { ref: 'header', className: 'ui-table-header' }),
            _react2.default.createElement('div', { ref: 'body', className: 'ui-table-body' }),
            this.renderXScroll(),
            this.renderYScroll(),
            this.renderAria()
        );
    };

    return UITable;
}(_UIView3.default);

UITable.propTypes = {
    columns: _react.PropTypes.arrayOf(_react.PropTypes.shape({
        mapping: _react.PropTypes.string,
        resizable: _react.PropTypes.bool,
        title: _react.PropTypes.string,
        width: _react.PropTypes.number
    })),
    getRow: _react.PropTypes.func,
    identifier: _react.PropTypes.string,
    jumpToRowIndex: _react.PropTypes.number,
    offscreenClass: _react.PropTypes.string,
    onCellInteract: _react.PropTypes.func,
    onColumnResize: _react.PropTypes.func,
    onRowInteract: _react.PropTypes.func,
    preserveScrollState: _react.PropTypes.bool,
    throttleInterval: _react.PropTypes.number,
    totalRows: _react.PropTypes.number
};
UITable.internal_keys = Object.keys(UITable.propTypes);
UITable.defaultProps = {
    className: '',
    offscreenClass: 'ui-offscreen',
    preserveScrollState: true
};
exports.default = UITable;
//# sourceMappingURL=data:application/json;base64,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QUlJLHVDQUFxQixLQUFLLEtBQUwsQ0FBVyxVQUpwQztBQUtJLDBCQUFTLEdBTGI7QUFNSSxtREFBSyxLQUFJLFFBQVQsRUFBa0IsV0FBVSxpQkFBNUIsR0FOSjtBQU9JLG1EQUFLLEtBQUksTUFBVCxFQUFnQixXQUFVLGVBQTFCLEdBUEo7QUFTSyxpQkFBSyxhQUFMLEVBVEw7QUFVSyxpQkFBSyxhQUFMLEVBVkw7QUFXSyxpQkFBSyxVQUFMO0FBWEwsU0FESjtBQWVILEs7Ozs7O0FBM0lnQixPLENBQ1YsUyxHQUFZO0FBQ2YsYUFBUyxpQkFBVSxPQUFWLENBQ0wsaUJBQVUsS0FBVixDQUFnQjtBQUNaLGlCQUFTLGlCQUFVLE1BRFA7QUFFWixtQkFBVyxpQkFBVSxJQUZUO0FBR1osZUFBTyxpQkFBVSxNQUhMO0FBSVosZUFBTyxpQkFBVTtBQUpMLEtBQWhCLENBREssQ0FETTtBQVNmLFlBQVEsaUJBQVUsSUFUSDtBQVVmLGdCQUFZLGlCQUFVLE1BVlA7QUFXZixvQkFBZ0IsaUJBQVUsTUFYWDtBQVlmLG9CQUFnQixpQkFBVSxNQVpYO0FBYWYsb0JBQWdCLGlCQUFVLElBYlg7QUFjZixvQkFBZ0IsaUJBQVUsSUFkWDtBQWVmLG1CQUFlLGlCQUFVLElBZlY7QUFnQmYseUJBQXFCLGlCQUFVLElBaEJoQjtBQWlCZixzQkFBa0IsaUJBQVUsTUFqQmI7QUFrQmYsZUFBVyxpQkFBVTtBQWxCTixDO0FBREYsTyxDQXNCVixhLEdBQWdCLE9BQU8sSUFBUCxDQUFZLFFBQVEsU0FBcEIsQztBQXRCTixPLENBd0JWLFksR0FBZTtBQUNsQixlQUFXLEVBRE87QUFFbEIsb0JBQWdCLGNBRkU7QUFHbEIseUJBQXFCO0FBSEgsQztrQkF4QkwsTyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3Qgd3JhcHBlciBmb3IgVGFibGUuXG4gKiBAY2xhc3MgVUlUYWJsZVxuICovXG5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoLm9taXQnO1xuaW1wb3J0IFRhYmxlIGZyb20gJ2VuaWdtYS10YWJsZSc7XG5cbmltcG9ydCBVSVZpZXcgZnJvbSAnLi4vVUlWaWV3JztcblxuZnVuY3Rpb24gZGlkQ29sdW1uc0NoYW5nZShjdXJyZW50X2NvbHVtbnMsIHByZXZfY29sdW1ucywgdGFibGVfaW50ZXJuYWxfY29sdW1ucykge1xuICAgIC8qXG4gICAgICAgIDEuIHRoZXJlIHNob3VsZCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgY29sdW1uc1xuICAgICAgICAyLiB0aGUgY29sdW1ucyBzaG91bGQgZXhhY3RseSBtYXRjaCBpbiB0aGUgcHJvcGVyIG9yZGVyXG4gICAgICAgIDMuIGVhY2ggY29sdW1uIHByb3BlcnR5IHNob3VsZCBiZSBleGFjdGx5IHRoZSBzYW1lXG4gICAgICovXG5cbiAgICBpZiAoY3VycmVudF9jb2x1bW5zLmxlbmd0aCAhPT0gcHJldl9jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBkaWQgdGhlIGNvbHVtbiBkZXNjcmlwdG9ycyBjaGFuZ2UgaW4gc29tZSB3YXksIG9yIGRpZCB0aGUgd2lkdGggY2hhbmdlP1xuICAgIC8vIHRoaXMgd2lsbCBhbHNvIGNhdGNoIGlmIHRoZSBvcmRlciBvZiB0aGUgY29sdW1ucyBjaGFuZ2VkIHdoZW4gY29tcGFyaW5nXG4gICAgLy8gdGhlIG1hcHBpbmcgcHJvcGVydHlcbiAgICByZXR1cm4gY3VycmVudF9jb2x1bW5zLnNvbWUoKGNvbHVtbiwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuICAgIGNvbHVtbi5tYXBwaW5nICE9PSBwcmV2X2NvbHVtbnNbaW5kZXhdLm1hcHBpbmdcbiAgICAgICAgICAgICAgIHx8IGNvbHVtbi50aXRsZSAhPT0gcHJldl9jb2x1bW5zW2luZGV4XS50aXRsZVxuICAgICAgICAgICAgICAgfHwgY29sdW1uLnJlc2l6YWJsZSAhPT0gcHJldl9jb2x1bW5zW2luZGV4XS5yZXNpemFibGVcbiAgICAgICAgICAgICAgIHx8IChjb2x1bW4ud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjb2x1bW4ud2lkdGggIT09IHRhYmxlX2ludGVybmFsX2NvbHVtbnNbaW5kZXhdLndpZHRoKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlUYWJsZSBleHRlbmRzIFVJVmlldyB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICAgICAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICAgICAgICAgIG1hcHBpbmc6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVzaXphYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgICAgICAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgICAgICAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIGdldFJvdzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGlkZW50aWZpZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGp1bXBUb1Jvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBvZmZzY3JlZW5DbGFzczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgb25DZWxsSW50ZXJhY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBvbkNvbHVtblJlc2l6ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG9uUm93SW50ZXJhY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBwcmVzZXJ2ZVNjcm9sbFN0YXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgdGhyb3R0bGVJbnRlcnZhbDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgdG90YWxSb3dzOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIH1cblxuICAgIHN0YXRpYyBpbnRlcm5hbF9rZXlzID0gT2JqZWN0LmtleXMoVUlUYWJsZS5wcm9wVHlwZXMpXG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgICBvZmZzY3JlZW5DbGFzczogJ3VpLW9mZnNjcmVlbicsXG4gICAgICAgIHByZXNlcnZlU2Nyb2xsU3RhdGU6IHRydWUsXG4gICAgfVxuXG4gICAgZ2V0U3Vidmlld0NvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cmFwcGVyOiB0aGlzLnJlZnMud3JhcHBlcixcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5yZWZzLmhlYWRlcixcbiAgICAgICAgICAgIGJvZHk6IHRoaXMucmVmcy5ib2R5LFxuICAgICAgICAgICAgJ3gtc2Nyb2xsLXRyYWNrJzogdGhpcy5yZWZzWyd4LXNjcm9sbC10cmFjayddLFxuICAgICAgICAgICAgJ3gtc2Nyb2xsLWhhbmRsZSc6IHRoaXMucmVmc1sneC1zY3JvbGwtaGFuZGxlJ10sXG4gICAgICAgICAgICAneS1zY3JvbGwtdHJhY2snOiB0aGlzLnJlZnNbJ3ktc2Nyb2xsLXRyYWNrJ10sXG4gICAgICAgICAgICAneS1zY3JvbGwtaGFuZGxlJzogdGhpcy5yZWZzWyd5LXNjcm9sbC1oYW5kbGUnXSxcbiAgICAgICAgICAgIGFyaWE6IHRoaXMucmVmcy5hcmlhLFxuXG4gICAgICAgICAgICBjb2x1bW5zOiB0aGlzLnByb3BzLmNvbHVtbnMsXG4gICAgICAgICAgICByb3dDbGlja0Z1bmM6IHRoaXMucHJvcHMub25Sb3dJbnRlcmFjdCxcbiAgICAgICAgICAgIGNlbGxDbGlja0Z1bmM6IHRoaXMucHJvcHMub25DZWxsSW50ZXJhY3QsXG4gICAgICAgICAgICBvbkNvbHVtblJlc2l6ZTogdGhpcy5wcm9wcy5vbkNvbHVtblJlc2l6ZSxcbiAgICAgICAgICAgIGdldFJvdzogdGhpcy5wcm9wcy5nZXRSb3csXG4gICAgICAgICAgICBwcmVzZXJ2ZVNjcm9sbFN0YXRlOiB0aGlzLnByb3BzLnByZXNlcnZlU2Nyb2xsU3RhdGUsXG4gICAgICAgICAgICB0aHJvdHRsZUludGVydmFsOiB0aGlzLnByb3BzLnRocm90dGxlSW50ZXJ2YWwsXG4gICAgICAgICAgICB0b3RhbFJvd3M6IHRoaXMucHJvcHMudG90YWxSb3dzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnRhYmxlID0gbmV3IFRhYmxlKHRoaXMuZ2V0U3Vidmlld0NvbmZpZ3VyYXRpb24oKSk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuanVtcFRvUm93SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGUuanVtcFRvUm93SW5kZXgodGhpcy5wcm9wcy5qdW1wVG9Sb3dJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50YWJsZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudGFibGUgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2X3Byb3BzKSB7XG4gICAgICAgIGNvbnN0IHtwcm9wc30gPSB0aGlzO1xuICAgICAgICBjb25zdCBjaGFuZ2VkX3Byb3BzID0gW107XG4gICAgICAgIGxldCBrZXk7XG5cbiAgICAgICAgLyogYmlkaXJlY3Rpb25hbCBrZXkgY2hhbmdlIGRldGVjdGlvbiAqL1xuXG4gICAgICAgIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPT0gcHJldl9wcm9wc1trZXldKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZF9wcm9wcy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBwcmV2X3Byb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJldl9wcm9wc1trZXldICE9PSBwcm9wc1trZXldICYmIGNoYW5nZWRfcHJvcHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRfcHJvcHMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZWRfcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZF9wcm9wcy5pbmRleE9mKCdqdW1wVG9Sb3dJbmRleCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8qIGp1bXBUb1Jvd0luZGV4IGFscmVhZHkgdHJpZ2dlcnMgYSByZWdlbmVyYXRpb24sIGp1c3QgYXZvaWRpbmcgcnVubmluZyBpdCB0d2ljZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlLmp1bXBUb1Jvd0luZGV4KHByb3BzLmp1bXBUb1Jvd0luZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZWRfcHJvcHMubGVuZ3RoID09PSAxICYmIGNoYW5nZWRfcHJvcHNbMF0gPT09ICdjb2x1bW5zJykge1xuICAgICAgICAgICAgICAgIC8qIGRpZCB0aGluZ3MgbWF0ZXJpYWxseSBjaGFuZ2UsIG9yIGp1c3QgdXBkYXRpbmcgYSBjb2x1bW4gd2lkdGg/ICovXG4gICAgICAgICAgICAgICAgaWYgKGRpZENvbHVtbnNDaGFuZ2UocHJvcHMuY29sdW1ucywgcHJldl9wcm9wcy5jb2x1bW5zLCB0aGlzLnRhYmxlLmNvbHVtbnMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRhYmxlLnJlZ2VuZXJhdGUodGhpcy5nZXRTdWJ2aWV3Q29uZmlndXJhdGlvbigpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlclhTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHJlZj0neC1zY3JvbGwtdHJhY2snIGNsYXNzTmFtZT0ndWktdGFibGUteC1zY3JvbGwtdHJhY2snPlxuICAgICAgICAgICAgICAgIDxkaXYgcmVmPSd4LXNjcm9sbC1oYW5kbGUnIGNsYXNzTmFtZT0ndWktdGFibGUteC1zY3JvbGwtaGFuZGxlJyAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyWVNjcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgcmVmPSd5LXNjcm9sbC10cmFjaycgY2xhc3NOYW1lPSd1aS10YWJsZS15LXNjcm9sbC10cmFjayc+XG4gICAgICAgICAgICAgICAgPGRpdiByZWY9J3ktc2Nyb2xsLWhhbmRsZScgY2xhc3NOYW1lPSd1aS10YWJsZS15LXNjcm9sbC1oYW5kbGUnIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJBcmlhKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiByZWY9J2FyaWEnIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5vZmZzY3JlZW5DbGFzcyB8fCAndWktb2Zmc2NyZWVuJ30gYXJpYS1saXZlPSdwb2xpdGUnIC8+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIHsuLi5vbWl0KHRoaXMucHJvcHMsIFVJVGFibGUuaW50ZXJuYWxfa2V5cyl9XG4gICAgICAgICAgICAgICAgcmVmPSd3cmFwcGVyJ1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17J3VpLXRhYmxlLXdyYXBwZXIgJyArIHRoaXMucHJvcHMuY2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIGRhdGEtc2V0LWlkZW50aWZpZXI9e3RoaXMucHJvcHMuaWRlbnRpZmllcn1cbiAgICAgICAgICAgICAgICB0YWJJbmRleD0nMCc+XG4gICAgICAgICAgICAgICAgPGRpdiByZWY9J2hlYWRlcicgY2xhc3NOYW1lPSd1aS10YWJsZS1oZWFkZXInIC8+XG4gICAgICAgICAgICAgICAgPGRpdiByZWY9J2JvZHknIGNsYXNzTmFtZT0ndWktdGFibGUtYm9keScgLz5cblxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlclhTY3JvbGwoKX1cbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJZU2Nyb2xsKCl9XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQXJpYSgpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl19
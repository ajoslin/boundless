/* eslint-disable no-console */

const fs = require('fs');
const path = require('path');
const mkdirp = require('mkdirp');
const chalk = require('chalk');
const _ = require('lodash');
const rollup = require('rollup');
const uglify = require('rollup-plugin-uglify');
const baseConfig = require('./rollup.config.js');

_.mixin({'pascalCase': _.flow(_.camelCase, _.upperFirst)});

const base = __dirname + '/../packages/';
const packages = fs.readdirSync(path.resolve(base)).filter((name) => /^boundless-(?!utils)/.test(name));
const error = (err) => console.error(chalk.bold.red(err));

const docgen = require('react-docgen');
const componentReadmeTemplate = `
THIS IS AN AUTOGENERATED FILE. EDIT INDEX.JS INSTEAD.

<%= description %>

### Props

_Note: only top-level props are in the README, for the full list check out the [website](http://boundless.js.org/<%= prettyName %>#props)._

<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Required</th>
        <th>Default Value</th>
    </tr>
    <% _.forIn(props, function(data, propName) { %>
    <tr>
        <td><%= propName %></td>
        <td><%= typeParser(data.type) %></td>
        <td><%= data.description %></td>
        <td><%= data.required %></td>
        <td><%= data.defaultValue.value %></td>
    </tr>
    <% }) %>
</table>
`.trim();
const componentReadmeGenerator = _.template(componentReadmeTemplate);

/*
    the boundless bundle needs some browser globals, so we'll just spawn a shared instance of jsdom
    and load the standalone version of boundless into it; we need the built version of boundless since
    node can't handle es6 module syntax yet ;_;
 */
require('jsdom').env('', [
    'http://cdnjs.cloudflare.com/ajax/libs/react/15.4.2/react.min.js',
    'http://cdnjs.cloudflare.com/ajax/libs/react/15.4.2/react-dom.min.js',
    path.resolve(`${__dirname}/../public/boundless.standalone.min.js`),
], (err, window) => {
    if (err) {
        return error(err);
    }

    const formatPropType = (type = {}) => {
        let str = type.name;

        switch (type.name) {
        case 'arrayOf':
            if (type.value.name !== 'custom') {
                str = `${type.name}(${type.value.name})`;
            }

            break;

        case 'enum':
            if (type.computed === true) {
                const prefix = type.value.split(/[()]+/)[1];

                str = 'enum([' + _.keys(
                    _.get(window.Boundless, prefix, {})
                ).map((key) => `${prefix}.${key}`).join(', ') + '])';
            } else {
                str = `enum(${type.value})`;
            }

            break;

        case 'union':
            str = type.value.map((v) => v.name.trim()).join('|');
            break;
        }

        return `\`${str}\``;
    };

    packages.forEach((name) => {
        const pascalName = _.pascalCase(name);
        const entryPath = path.resolve(base + name + '/index.js');
        const readmePath = path.resolve(base + name + '/README.md');

        fs.writeFileSync(readmePath, componentReadmeGenerator(
            _.merge({}, docgen.parse(fs.readFileSync(entryPath)), {
                prettyName: pascalName.replace('Boundless', ''),
                typeParser: formatPropType,
            })
        ));

        mkdirp.sync(path.resolve(base + name + '/build'));

        process.env.BABEL_ENV = 'development';

        const devRollupInstance = rollup.rollup(_.assign({}, baseConfig, {
            entry: entryPath,
            plugins: baseConfig.plugins.concat(
                uglify({
                    compress: false,
                    screwIE8: true,
                })
            ),
        }));

        Promise.all([
            devRollupInstance.then((bundle) => bundle.write({
                dest: path.resolve(base + name + '/build/index.js'),
                format: 'cjs',
                sourceMap: 'inline',
            }), error),

            devRollupInstance.then((bundle) => bundle.write({
                dest: path.resolve(base + name + '/build/index.standalone.js'),
                format: 'iife',
                globals: {
                    'react': 'React',
                    'react-dom': 'ReactDOM',
                },
                moduleName: pascalName,
            }), error),
        ]).then(() => {
            process.env.BABEL_ENV = 'production';

            rollup.rollup(_.assign({}, baseConfig, {
                entry: entryPath,
                plugins: baseConfig.plugins.concat(
                    uglify({
                        compress: {
                            'drop_console': true,
                        },
                        screwIE8: true,
                    })
                ),
            })).then((bundle) => bundle.write({
                dest: path.resolve(base + name + '/build/index.standalone.min.js'),
                format: 'iife',
                globals: {
                    'react': 'React',
                    'react-dom': 'ReactDOM',
                },
                moduleName: pascalName,
            })).catch(error);
        }, error).then(() => console.log(chalk.bold.green(`Built ${name}.`)), error);
    });
});
